#include "piobjc.h"
#import "ObjC.h"
#import <Foundation/NSBundle.h>
#import <Foundation/NSString.h>
#import <Foundation/NSAutoreleasePool.h>
#import <Foundation/NSThread.h>

/*! @decl int index(int pid, int use_main_thread, string bundlePath, string systemPath, string carbonPath)
 *!
 */
CVAR NSAutoreleasePool * pool;

PIKEFUN void create()
{
}

#if defined(MAC_OS_X_VERSION_10_3) && defined(__ppc__)
PIKEFUN int inject(int pid, int use_main_thread, string bundlePath, string systemPath, string carbonPath)
{
  int r;

  r = objc_inject(pid, use_main_thread, bundlePath->str, systemPath->str, carbonPath->str);

  pop_n_elems(args);
  push_int(r);
  return;
}
#endif

PIKEFUN array list_classes()
{
  Class * list = NULL;
  int buflen = 0;
  int r = 0;

  buflen = objc_getClassList(NULL, NULL);

  printf("have %d registered classes\n", buflen);

  list = malloc(buflen * sizeof(Class));

  if(list == NULL)
    Pike_error("unable to allocate memory.\n");

  r = objc_getClassList(list, buflen);

  for(buflen = 0; buflen < r; buflen++)
  {
    push_text(list[buflen]->name);
  }

  free(list);

  f_aggregate(r);
}


EXTRA
{
  id init_pool;

      if (![NSThread isMultiThreaded]) {
	    printf("going Multi-threaded for cocoa.\n");
        [NSThread detachNewThreadSelector:@selector(targetForBecomingMultiThreaded:)
            toTarget:[OC_NSAutoreleasePoolCollector class] withObject:nil];
      }


  init_pool = [[NSAutoreleasePool alloc] init];

  add_string_constant("__version", "0.1", 0);
  add_string_constant("__author", "Bill Welliver <bill@welliver.org>", 0);

  pike_init_piobjc_nsclass();
  pike_init_piobjc_nsobject();
  pike_init_piobjc_nsstring();
  pike_init_piobjc_methodwrapper();
 // pike_init_piobjc_piobjcobject();
  [init_pool release];
  //[OC_NSAutoreleasePoolCollector newAutoreleasePool];
}

INIT
{
 if(THIS->pool == NULL)   THIS->pool = [[NSAutoreleasePool alloc] init];

}

EXIT
{
  pike_exit_piobjc_nsstring();
  pike_exit_piobjc_nsclass();
  pike_exit_piobjc_nsobject();
  pike_exit_piobjc_methodwrapper();
  //pike_exit_piobjc_piobjcobject();
}

PIKEFUN void new_class(string name)
{
   add_piobjcclass(name->str);
   pop_stack();
}

void add_piobjcclass(char * name)
{
  int res;
  res = CreateClassDefinition(name, "NSProxy");  

  if(res == YES)
    printf("Success!\n");
  else
    printf("Failure!\n");
}

PIKEFUN int low_load_bundle(string bundle_path)
{
 NSBundle* bundle = nil;
 id bundle_identifier = nil;
 id bundlePath = nil;
 
 bundlePath = [NSString stringWithCString: bundle_path->str length: bundle_path->len];

 bundle = [NSBundle bundleWithPath:bundlePath];

  if(![bundle load])
  {
	Pike_error("Bundle could not be loaded.\n");
  }

  pop_stack();
  push_int(0);
  
}
// this method comes to us from the Apple C Runtime Reference manual.
// we should eventually rewrite it with our own brains.
BOOL CreateClassDefinition( const char * name, 
        const char * superclassName )
{
    struct objc_class * meta_class;
    struct objc_class * super_class;
    struct objc_class * new_class;
    struct objc_class * root_class;

    // Ensure that the superclass exists and that someone
    // hasn't already implemented a class with the same name
    //

    super_class = (struct objc_class *)objc_lookUpClass (superclassName);

    if (super_class == nil)
    {
        return NO;
    }

    if (objc_lookUpClass (name) != nil) 
    {
        return NO;
    }

    // Find the root class
    //

    root_class = super_class;

    while( root_class->super_class != nil )
    {
        root_class = root_class->super_class;
    }

    // Allocate space for the class and its metaclass
    //

    new_class = calloc( 2, sizeof(struct objc_class) );
    meta_class = &new_class[1];

    // setup class
    new_class->isa      = meta_class;
    new_class->info     = CLS_CLASS;
    meta_class->info    = CLS_META;

    // Create a copy of the class name.
    // For efficiency, we have the metaclass and the class itself 
    // to share this copy of the name, but this is not a requirement
    // imposed by the runtime.
    //
    new_class->name = malloc (strlen (name) + 1);
    strcpy ((char*)new_class->name, name);
    meta_class->name = new_class->name;

    // Allocate empty method lists.
    // We can add methods later.
    //

    new_class->methodLists = calloc( 1, sizeof(struct objc_method_list  *) );
    *new_class->methodLists = -1;
    meta_class->methodLists = calloc( 1, sizeof(struct objc_method_list  *) );
    *meta_class->methodLists = -1;

    // Connect the class definition to the class hierarchy:
    // Connect the class to the superclass.
    // Connect the metaclass to the metaclass of the superclass.
    // Connect the metaclass of the metaclass to the metaclass of  the root class.
    //

    new_class->super_class  = super_class;
    meta_class->super_class = super_class->isa;
    meta_class->isa         = (void *)root_class->isa;

    // Set the sizes of the class and the metaclass.
    //

    new_class->instance_size = super_class->instance_size;
    meta_class->instance_size = meta_class->super_class->instance_size;

    // Finally, register the class with the runtime.
    //

    objc_addClass( new_class ); 
    return YES;

}

unsigned pike_objc_type_alignment(char** typeptr){
	unsigned result=0;
	char* type=*typeptr;
	start:{
		char this=*type;
		type++;
		switch(this){
			case 'b':
#ifndef __NEXT_RUNTIME__
				pike_objc_type_skip_number(type);
				result=pike_objc_type_alignment(&type);
				pike_objc_type_skip_number(type);
				break;
#else
				result=__alignof__(int);
				pike_objc_type_skip_number(type);
				break;
#endif
			case 'c':
				result=__alignof__(char);
				break;
			case 'C':
				result=__alignof__(unsigned char);
				break;
			case 'd':
				result=__alignof__(double);
				break;
			case 'f':
				result=__alignof__(float);
				break;
			case 'i':
				result=__alignof__(int);
				break;
			case 'I':
				result=__alignof__(unsigned int);
				break;
			case 'l':
				result=__alignof__(long);
				break;
			case 'L':
				result=__alignof__(unsigned long);
				break;
			case 'n':
			case 'N':
			case 'o':
			case 'O':
				goto start;
			case 'q':
				result=__alignof__(long long);
				break;
			case 'Q':
				result=__alignof__(unsigned long long);
				break;
			case 'r':
				goto start;
			case 's':
				result=__alignof__(short);
				break;
			case 'S':
				result=__alignof__(unsigned short);
				break;
			case 'v':
				result=__alignof__(void);
				break;
			case 'V':
				goto start;
			case '@':
				result=__alignof__(id);
				break;
			case '#':
				result=__alignof__(Class);
				break;
			case '^':
				result=__alignof__(void*);
				pike_objc_type_alignment(&type);
				break;
			case '*':
				result=__alignof__(char*);
				break;
			case ':':
				result=__alignof__(SEL);
				break;
			case '(':{
				pike_objc_type_skip_name(type);
				if(*type){
					while((*type)&&(*type!=')')){
						unsigned alignment=pike_objc_type_alignment(&type);
						if(alignment>result)
							result=alignment;
						}
					pike_objc_type_skip_past_char(type,')');
					}
				break;
				}
			case '[':{
				pike_objc_type_skip_number(type);
				if(*type){
					unsigned alignment=pike_objc_type_alignment(&type);
					pike_objc_type_skip_past_char(type,']');
					result=alignment;
					}
				break;
				}
			case '{':{
				pike_objc_type_skip_name(type);
				if(*type){
					while((*type)&&(*type!='}')){
						unsigned alignment=pike_objc_type_alignment(&type);
						if(alignment>result)
							result=alignment;
						}
					pike_objc_type_skip_past_char(type,'}');
					}
				break;
				}
			case '?':
			default:
				result=0;
			}
		pike_objc_type_skip_number(type);
		}
	*typeptr=(result?type:nil);
	return result;
	}


unsigned pike_objc_type_size(char** typeptr){
	unsigned result=0;
	char* type=*typeptr;
	start:{
		char this=*type;
		type++;
		switch(this){
			case 'b':
#ifndef __NEXT_RUNTIME__
				pike_objc_type_skip_number(type);
				result=pike_objc_type_size(&type);
				pike_objc_type_skip_number(type);
				break;
#else
				result=sizeof(int);
				pike_objc_type_skip_number(type);
				break;
#endif
			case 'c':
				result=sizeof(char);
				break;
			case 'C':
				result=sizeof(unsigned char);
				break;
			case 'd':
				result=sizeof(double);
				break;
			case 'f':
				result=sizeof(float);
				break;
			case 'i':
				result=sizeof(int);
				break;
			case 'I':
				result=sizeof(unsigned int);
				break;
			case 'l':
				result=sizeof(long);
				break;
			case 'L':
				result=sizeof(unsigned long);
				break;
			case 'n':
			case 'N':
			case 'o':
			case 'O':
				goto start;
			case 'q':
				result=sizeof(long long);
				break;
			case 'Q':
				result=sizeof(unsigned long long);
				break;
			case 'r':
				goto start;
			case 's':
				result=sizeof(short);
				break;
			case 'S':
				result=sizeof(unsigned short);
				break;
			case 'v':
				result=sizeof(void);
				break;
			case 'V':
				goto start;
			case '@':
				result=sizeof(id);
				break;
			case '#':
				result=sizeof(Class);
				break;
			case '^':
				result=sizeof(void*);
				pike_objc_type_size(&type);
				break;
			case '*':
				result=sizeof(char*);
				break;
			case ':':
				result=sizeof(SEL);
				break;
			case '(':{
				pike_objc_type_skip_name(type);
				if(*type){
					while((*type)&&(*type!=')')){
						unsigned size=pike_objc_type_size(&type);
						if(size>result)
							result=size;
						}
					pike_objc_type_skip_past_char(type,')');
					}
				break;
				}
			case '[':{
				unsigned count=0;
				while((*type)&&((*type)>='0')&&((*type)<='9')){
					count=((*type)-'0')+(count*10);
					type++;
					}
				if(*type){
					result=count*pike_objc_type_size(&type);
					pike_objc_type_skip_past_char(type,']');
					}
				else
					result=0;
				break;
				}
			case '{':{
				unsigned max_alignment=0;
				unsigned padding;
				char* temp;
				unsigned this_alignment;
				pike_objc_type_skip_name(type);
				if(*type){
					while((*type)&&(*type!='}')){
						temp=type;
						this_alignment=pike_objc_type_alignment(&temp);

						if(this_alignment>4)
							this_alignment=4;
						if(this_alignment>max_alignment)
							max_alignment=this_alignment;

						if(result&(this_alignment-1))
							padding=this_alignment-((result&(this_alignment-1)));
						else
							padding=0;
						result=result+pike_objc_type_size(&type)+padding;
						}
					if(result&(max_alignment-1))
						padding=max_alignment-((result&(max_alignment-1)));
					else
						padding=0;
					result=result+padding;
					pike_objc_type_skip_past_char(type,'}');
					}
				break;
				}
			case '?':
			default:
				result=0;
			}
		pike_objc_type_skip_number(type);
		}
	*typeptr=(result?type:nil);
	return result;
	}
