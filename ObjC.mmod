
#define THIS_IS_OBJC_OBJECT_HOLDER 1

#include "mach_override.h"
#include "libffi/include/ffi.h"
#include "piobjc.h"
#import "util.h"
#import "ObjC.h"
#import <Foundation/NSBundle.h>
#import <Foundation/NSString.h>
#import <Foundation/NSAutoreleasePool.h>
#import <Foundation/NSThread.h>
/*! @decl int index(int pid, int use_main_thread, string bundlePath, string systemPath, string carbonPath)
 *!
 */

object_setInstanceVariableProc old_objectSetInstanceVariable;

id global_autorelease_pool;
struct mapping * global_class_cache;
struct mapping * global_classname_cache;

CVAR OC_NSAutoreleasePoolCollector * pool;

PIKEFUN void create()
{
}

#if defined(MAC_OS_X_VERSION_10_3) && defined(__ppc__)
PIKEFUN int inject(int pid, int use_main_thread, string bundlePath, string systemPath, string carbonPath)
{
  int r;

//  r = objc_inject(pid, use_main_thread, bundlePath->str, systemPath->str, carbonPath->str);

  pop_n_elems(args);
  push_int(r);
  return;
}
#endif

PIKEFUN void purge_autorelease_pool()
{
	[global_autorelease_pool purgeAndNew];
	return;
}

PIKEFUN program get_dynamic_class(string classname)
{
   struct program * prog;
   
   prog = pike_create_objc_dynamic_class(classname);
   
   pop_stack();
   
   if(prog)
      ref_push_program(prog);
   else
      push_int(0);
}

PIKEFUN array list_classes()
{
  Class * list = NULL;
  int buflen = 0;
  int r = 0;

  buflen = objc_getClassList(NULL, 0);

  printf("have %d registered classes\n", buflen);

  list = malloc(buflen * sizeof(Class));

  if(list == NULL)
    Pike_error("unable to allocate memory.\n");

  r = objc_getClassList(list, buflen);

  for(buflen = 0; buflen < r; buflen++)
  {
    push_text(list[buflen]->name);
  }

  free(list);

  f_aggregate(r);
}


EXTRA
{
  id init_pool;

      if (![NSThread isMultiThreaded]) {
//	    printf("going Multi-threaded for cocoa.\n");
        [NSThread detachNewThreadSelector:@selector(targetForBecomingMultiThreaded:)
            toTarget:[[OC_NSAutoreleasePoolCollector alloc] init] withObject:nil];

      }

  init_pool = [[NSAutoreleasePool alloc] init];

  override_object_setInstanceVariable();

  add_string_constant("__version", "0.1", 0);
  add_string_constant("__author", "Bill Welliver <bill@welliver.org>", 0);

  pike_init_piobjc_appkit();
  [init_pool release];
  global_autorelease_pool = [[OC_NSAutoreleasePoolCollector alloc] init];
}

INIT
{

  THIS->pool = [[OC_NSAutoreleasePoolCollector alloc] init];
  [THIS->pool newAutoreleasePool];

 global_class_cache = allocate_mapping(10);
 global_classname_cache = allocate_mapping(10);
 add_ref(global_class_cache);
 add_ref(global_classname_cache);
}

EXIT
{
  pike_exit_piobjc_appkit();
  free_mapping(global_class_cache);
  free_mapping(global_classname_cache);
}

PIKEFUN void new_class(string name, program p)
{
   add_piobjcclass(name->str, p);
   pop_n_elems(args);
}


// set up method override for 
void override_object_setInstanceVariable()
{

  kern_return_t err = mach_override("_object_setInstanceVariable", NULL, 
                                    (void*)new_object_setInstanceVariable, 
                                    (void**)&old_object_setInstanceVariable
                                    );
  if(err)
  {
      Pike_error("an error occurred while setting up the Objective-C environment.\n");
  }
}

Ivar new_object_setInstanceVariable(id object, const char *name, void *value)
{
  printf("new_object_setInstanceVariable()\n");
  return (old_object_setInstanceVariable(object, name, value));
}

void add_piobjcclass(char * name, struct program * prog)
{
  int res;
  res = CreateClassDefinition(name, "PiObjCObject", prog);  

  if(res == NO)
    Pike_error("Error occurred while registering the Objective-C bridge class\n");
}

PIKEFUN int low_load_bundle(string bundle_path)
{
 NSBundle* bundle = nil;
 id bundle_identifier = nil;
 id bundlePath = nil;
 
 bundlePath = [NSString stringWithCString: bundle_path->str length: bundle_path->len];

 bundle = [NSBundle bundleWithPath:bundlePath];

  if(![bundle load])
  {
	Pike_error("Bundle could not be loaded.\n");
  }

  pop_stack();
  push_int(0);
  
}
// this method comes to us from the Apple C Runtime Reference manual.
// we should eventually rewrite it with our own brains.
BOOL CreateClassDefinition( const char * name, 
        const char * superclassName, struct program * prog)
{
    struct objc_class * meta_class;
    struct objc_class * super_class;
    struct objc_class * new_class;
    struct objc_class * root_class;
	struct objc_method_list ** emptyMethodLists;
 
    // Ensure that the superclass exists and that someone
    // hasn't already implemented a class with the same name
    //

    super_class = (struct objc_class *)objc_lookUpClass (superclassName);

    if (super_class == nil)
    {
        return NO;
    }

    if (objc_lookUpClass (name) != nil) 
    {
        return NO;
    }

    // Find the root class
    //

    root_class = super_class;

    while( root_class->super_class != nil )
    {
        root_class = root_class->super_class;
    }

    // Allocate space for the class and its metaclass
    //

    new_class = calloc( 2, sizeof(struct objc_class) );
    meta_class = &new_class[1];

    // setup class
    new_class->isa      = meta_class;
    new_class->info     = CLS_CLASS;
    meta_class->info    = CLS_META;

    // Create a copy of the class name.
    // For efficiency, we have the metaclass and the class itself 
    // to share this copy of the name, but this is not a requirement
    // imposed by the runtime.
    //
    new_class->name = malloc (strlen (name) + 1);
    strcpy ((char*)new_class->name, name);
    meta_class->name = new_class->name;

    // Allocate empty method lists.
    // We can add methods later.
    //

    new_class->methodLists = calloc( 1, sizeof(struct objc_method_list  *) );
    *new_class->methodLists = NULL;
    meta_class->methodLists = calloc( 1, sizeof(struct objc_method_list  *) );
    *meta_class->methodLists = NULL;

    // Connect the class definition to the class hierarchy:
    // Connect the class to the superclass.
    // Connect the metaclass to the metaclass of the superclass.
    // Connect the metaclass of the metaclass to the metaclass of  the root class.
    //

    new_class->super_class  = super_class;
    meta_class->super_class = super_class->isa;
    meta_class->isa         = (void *)root_class->isa;

    // Set the sizes of the class and the metaclass.
    //

    new_class->instance_size = super_class->instance_size;
    meta_class->instance_size = meta_class->super_class->instance_size;


    // We will add our methods later, so the list of lists starts with just end-of-list
    emptyMethodLists = malloc( sizeof(void *) );
    *emptyMethodLists = ((struct objc_method_list*)-1); // See objc-private.h in Darwin

	new_class->methodLists = emptyMethodLists;

/*
	new_method_list->method_list[0].method_name = sel_registerName("whee");
	new_method_list->method_list[0].method_types = strdup("@@:");
	new_method_list->method_list[0].method_imp = make_stub(prog);
*/	
	
  //  RegisterInstanceVariables(new_class, prog);

    // Finally, register the class with the runtime.
    objc_addClass( new_class ); 

    RegisterDynamicMethod("init", name, (IMP)make_init_stub(prog), "@4@4:4");
    RegisterDynamicMethod("__ObjCgetPikeObject", name, (IMP)get_objc_object, "@4@4:4");
    //RegisterDynamicMethod("convert:", name, (IMP)_convert, "v4@4:4");
    
    return YES;

}

BOOL RegisterInstanceVariables(Class cls, struct program * prog)
{
   int z = 0;
   int q = 0;
   int num_vars = 0;
   struct objc_ivar_list * l;
   int offset;
      
   printf("  %d identifiers\n", prog->num_identifiers);
   for(z = 0; z < prog->num_identifiers; z++)
   {
      struct identifier i;
      
      i = prog->identifiers[z];
      
      if(IDENTIFIER_IS_VARIABLE(i.identifier_flags))
      {
         num_vars++;
      }      
   }

   if(num_vars == 0)
   {
     cls->ivars = NULL;
     return;
   }  
   
   l = malloc(sizeof(struct objc_ivar_list) + ((num_vars) * sizeof(struct objc_ivar) ));

   l->ivar_count = 0;
   
   if(l == NULL)
   {
     Pike_error("unable to allocate memory.\n");
   }
   
   offset = cls->super_class->instance_size;
   
   for(z = 0; z < prog->num_identifiers; z++)
   {
     struct identifier i;
     struct objc_ivar * v;
     
     i = prog->identifiers[z];
   
     if(IDENTIFIER_IS_VARIABLE(i.identifier_flags))
     {
       char * ivn;
       
       v = l->ivar_list + l->ivar_count;
       ivn = malloc(i.name->len);
       strncpy(ivn, i.name->str, i.name->len);     
       v->ivar_name = ivn;
       
       v->ivar_type = @encode(id);
       v->ivar_offset = offset;
       offset += sizeof(id);
       l->ivar_count++;
       printf("added ivar!\n");
     }      
   }

   cls->ivars = l;

   for(z = 0; z < cls->ivars->ivar_count; z++)
   {
      printf("registered variable %s of type %s\n", cls->ivars->ivar_list[z].ivar_name, cls->ivars->ivar_list[z].ivar_type);
   }

   cls->instance_size = offset;

}

BOOL RegisterDynamicMethod( const char * dynamicMethodName, const char * className, IMP method, char * methodTypes )
{
    BOOL result = FALSE;
    
    // Get the class object we want to add the method to
    id methodClass = objc_getClass( className );
    
    // Make sure the class we're trying to attach a method to exists
   if( methodClass != Nil )
    {
        struct objc_method_list * methodList = malloc( sizeof( struct objc_method_list ) );
        
        // Get or register the selector for the method name
        SEL methodSEL = SELUID( dynamicMethodName );
    
        // Fill out the method list
        methodList->method_count = 1;
        methodList->method_list[ 0 ].method_name = methodSEL;
        methodList->method_list[ 0 ].method_types = methodTypes;
        methodList->method_list[ 0 ].method_imp = method;
        
        // Register our method
        class_addMethods(methodClass, methodList);
        
        result = TRUE;
    }
        
    return result;
}

unsigned pike_objc_type_alignment(char** typeptr){
	unsigned result=0;
	char* type=*typeptr;
	start:{
		char this=*type;
		type++;
		switch(this){
			case 'b':
#ifndef __NEXT_RUNTIME__
				pike_objc_type_skip_number(type);
				result=pike_objc_type_alignment(&type);
				pike_objc_type_skip_number(type);
				break;
#else
				result=__alignof__(int);
				pike_objc_type_skip_number(type);
				break;
#endif
			case 'c':
				result=__alignof__(char);
				break;
			case 'C':
				result=__alignof__(unsigned char);
				break;
			case 'd':
				result=__alignof__(double);
				break;
			case 'f':
				result=__alignof__(float);
				break;
			case 'i':
				result=__alignof__(int);
				break;
			case 'I':
				result=__alignof__(unsigned int);
				break;
			case 'l':
				result=__alignof__(long);
				break;
			case 'L':
				result=__alignof__(unsigned long);
				break;
			case 'n':
			case 'N':
			case 'o':
			case 'O':
				goto start;
			case 'q':
				result=__alignof__(long long);
				break;
			case 'Q':
				result=__alignof__(unsigned long long);
				break;
			case 'r':
				goto start;
			case 's':
				result=__alignof__(short);
				break;
			case 'S':
				result=__alignof__(unsigned short);
				break;
			case 'v':
				result=__alignof__(void);
				break;
			case 'V':
				goto start;
			case '@':
				result=__alignof__(id);
				break;
			case '#':
				result=__alignof__(Class);
				break;
			case '^':
				result=__alignof__(void*);
				pike_objc_type_alignment(&type);
				break;
			case '*':
				result=__alignof__(char*);
				break;
			case ':':
				result=__alignof__(SEL);
				break;
			case '(':{
				pike_objc_type_skip_name(type);
				if(*type){
					while((*type)&&(*type!=')')){
						unsigned alignment=pike_objc_type_alignment(&type);
						if(alignment>result)
							result=alignment;
						}
					pike_objc_type_skip_past_char(type,')');
					}
				break;
				}
			case '[':{
				pike_objc_type_skip_number(type);
				if(*type){
					unsigned alignment=pike_objc_type_alignment(&type);
					pike_objc_type_skip_past_char(type,']');
					result=alignment;
					}
				break;
				}
			case '{':{
				pike_objc_type_skip_name(type);
				if(*type){
					while((*type)&&(*type!='}')){
						unsigned alignment=pike_objc_type_alignment(&type);
						if(alignment>result)
							result=alignment;
						}
					pike_objc_type_skip_past_char(type,'}');
					}
				break;
				}
			case '?':
			default:
				result=0;
			}
		pike_objc_type_skip_number(type);
		}
	*typeptr=(result?type:nil);
	return result;
	}


unsigned pike_objc_type_size(char** typeptr){
	unsigned result=0;
	char* type=*typeptr;
	start:{
		char this=*type;
		type++;
		switch(this){
			case 'b':
#ifndef __NEXT_RUNTIME__
				pike_objc_type_skip_number(type);
				result=pike_objc_type_size(&type);
				pike_objc_type_skip_number(type);
				break;
#else
				result=sizeof(int);
				pike_objc_type_skip_number(type);
				break;
#endif
			case 'c':
				result=sizeof(char);
				break;
			case 'C':
				result=sizeof(unsigned char);
				break;
			case 'd':
				result=sizeof(double);
				break;
			case 'f':
				result=sizeof(float);
				break;
			case 'i':
				result=sizeof(int);
				break;
			case 'I':
				result=sizeof(unsigned int);
				break;
			case 'l':
				result=sizeof(long);
				break;
			case 'L':
				result=sizeof(unsigned long);
				break;
			case 'n':
			case 'N':
			case 'o':
			case 'O':
				goto start;
			case 'q':
				result=sizeof(long long);
				break;
			case 'Q':
				result=sizeof(unsigned long long);
				break;
			case 'r':
				goto start;
			case 's':
				result=sizeof(short);
				break;
			case 'S':
				result=sizeof(unsigned short);
				break;
			case 'v':
				result=sizeof(void);
				break;
			case 'V':
				goto start;
			case '@':
				result=sizeof(id);
				break;
			case '#':
				result=sizeof(Class);
				break;
			case '^':
				result=sizeof(void*);
				pike_objc_type_size(&type);
				break;
			case '*':
				result=sizeof(char*);
				break;
			case ':':
				result=sizeof(SEL);
				break;
			case '(':{
				pike_objc_type_skip_name(type);
				if(*type){
					while((*type)&&(*type!=')')){
						unsigned size=pike_objc_type_size(&type);
						if(size>result)
							result=size;
						}
					pike_objc_type_skip_past_char(type,')');
					}
				break;
				}
			case '[':{
				unsigned count=0;
				while((*type)&&((*type)>='0')&&((*type)<='9')){
					count=((*type)-'0')+(count*10);
					type++;
					}
				if(*type){
					result=count*pike_objc_type_size(&type);
					pike_objc_type_skip_past_char(type,']');
					}
				else
					result=0;
				break;
				}
			case '{':{
				unsigned max_alignment=0;
				unsigned padding;
				char* temp;
				unsigned this_alignment;
				pike_objc_type_skip_name(type);
				if(*type){
					while((*type)&&(*type!='}')){
						temp=type;
						this_alignment=pike_objc_type_alignment(&temp);

						if(this_alignment>4)
							this_alignment=4;
						if(this_alignment>max_alignment)
							max_alignment=this_alignment;

						if(result&(this_alignment-1))
							padding=this_alignment-((result&(this_alignment-1)));
						else
							padding=0;
						result=result+pike_objc_type_size(&type)+padding;
						}
					if(result&(max_alignment-1))
						padding=max_alignment-((result&(max_alignment-1)));
					else
						padding=0;
					result=result+padding;
					pike_objc_type_skip_past_char(type,'}');
					}
				break;
				}
			case '?':
			default:
				result=0;
			}
		pike_objc_type_skip_number(type);
		}
	*typeptr=(result?type:nil);
	return result;
	}

