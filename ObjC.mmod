/* 
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 *
 * $Id: ObjC.mmod,v 1.1.1.1 2005-09-15 20:55:52 hww3 Exp $
 */

/*
 * File licensing and authorship information block.
 *
 * Version: MPL 1.1/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Initial Developer of the Original Code is
 *
 * Bill Welliver <hww3@riverweb.com>
 *
 * Portions created by the Initial Developer are Copyright (C) Bill Welliver
 * All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of the LGPL, and not to allow others to use your version
 * of this file under the terms of the MPL, indicate your decision by
 * deleting the provisions above and replace them with the notice
 * and other provisions required by the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL or the LGPL.
 *
 * Significant Contributors to this file are:
 *
 */

/*! @module Public
 */

/*! @module ObjectiveC
 */

/*! @class ObjectiveC
 */

#define _GNU_SOURCE

#include "objectivec_config.h"
#include "util.h"

#define NEW_NSOBJECT() clone_object(NSObject_program, 0)

#ifdef HAVE_FFI
#endif /* HAVE_FFI */

#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif

#include <stdlib.h>
#include <stdio.h>
#include <errno.h>
#include <string.h>

#ifdef HAVE_FFI_H
#include <ffi.h>
#endif

#ifdef HAVE_FFI_CONFIG_H
#include <ffi_config.h>
#endif

#ifdef HAVE_OBJC_OBJC_H
#include <objc/objc.h>
#endif

#ifdef HAVE_OBJC_OBJC_CLASS_H
#include <objc/objc-class.h>
#endif

PIKECLASS NSObject
{

typedef struct
{
    id object;
} NSOBJECT_OBJECT_DATA;

CVAR NSOBJECT_OBJECT_DATA   *object_data;

PIKEFUN mixed send(string selector, mixed ... my_arguments)
{
  struct objc_method * method;
  SEL * select;
  int arguments, x;
  marg_list argumentList=NULL;
  int argumentOffset=0;
    char * type = NULL;

  void * result;

  select = sel_registerName(selector->str);

  [ THIS->object_data->object retain ];

  method = class_getInstanceMethod(THIS->object_data->object->isa, select);
  if(method == NULL)
    method = class_getClassMethod(THIS->object_data->object->isa, select);

  if(method == NULL ) Pike_error("method does not exist.\n");

  arguments = method_getNumberOfArguments(method);

  if((args-1) != (arguments-2))
    Pike_error("incorrect number of arguments to method provided.\n");


  marg_malloc(argumentList,method);
  if(!argumentList)
    Pike_error("Insufficient memory (Could not allocate method argument buffer).");

  // arguments 0 and 1 are the object to recieve the message and the selector, respectively.
  for(x = 2; x < arguments; x++)
  {
    int offset;
      struct svalue * sv;
      sv = my_arguments+(x-2);

    method_getArgumentInfo(method, x, &type, &offset);

    while((*type)&&(*type=='r' || *type =='n' || *type =='N' || type=='o' || type=='O' || type =='V'))
		type++;

    switch(*type)
    {
      case 'c': 
         if(sv->type!=T_INT)
           Pike_error("Type mismatch for method argument.");
         marg_setValue(argumentList,offset,char, sv->u.integer);
	 break;

      case 'C': 
         if(sv->type!=T_INT)
           Pike_error("Type mismatch for method argument.");
         marg_setValue(argumentList,offset,unsigned char, sv->u.integer);
	 break;

      case 'i': 
         if(sv->type!=T_INT)
           Pike_error("Type mismatch for method argument.");
         marg_setValue(argumentList,offset,int, sv->u.integer);
	 break;

      case 'I': 
         if(sv->type!=T_INT)
           Pike_error("Type mismatch for method argument.");
         marg_setValue(argumentList,offset,unsigned int, sv->u.integer);
	 break;

      case '*': 
         if(sv->type!=T_STRING)
           Pike_error("Type mismatch for method argument..");
         marg_setValue(argumentList,offset,char *, sv->u.string->str);
	 break;

      case '@': 
         if(sv->type!=T_OBJECT)
           Pike_error("Type mismatch for method argument..");
         {
           struct object * o = sv->u.object;
           if(!get_storage(o, NSObject_program))
             Pike_error("NSObject not passed.\n");
           marg_setValue(argumentList,offset,id, OBJ2_NSOBJECT(o)->object_data->object);
         }
	 break;

      default:
         Pike_error("unsupported argument type.\n");

      }
   }

  type = method->method_types;

  while((*type)&&(*type=='r' || *type =='n' || *type =='N' || type=='o' || type=='O' || type =='V'))
		type++;

  printf("TYPE: %s\n", type);

  switch(*(type)){
    case 'b':
      Pike_error("Invalid return type for method.");
    case '?':
      Pike_error("Unknown return type for method.");
    case '[':
    case '{':
    case '(':{
      char* temp=method->method_types;
      result=xmalloc(pike_objc_type_size(&temp));
      objc_msgSendv_stret(result,THIS->object_data->object,select,method_getSizeOfArguments(method),argumentList);
      break;
    }

    default:
      result=objc_msgSendv(THIS->object_data->object,select,method_getSizeOfArguments(method),argumentList);
  }

  pop_n_elems(args);

  printf("%s\n", type);

  switch(*type){
    case 'b':
      break;
    case 'c':
      push_int((char)result);
      break;
    case 'i':
      push_int((int)result);
      break;
    case 'I':
      push_int((unsigned int)result);
      break;
    case '*':
      push_text((char *)result);
      break;
    case '@':
      {
        struct object * o;
        o = NEW_NSOBJECT();
        OBJ2_NSOBJECT(o)->object_data->object = (id)result;
        push_object(o);
      }
  }

  if(argumentList) 
    marg_free(argumentList);

}


INIT
{
    NSOBJECT_OBJECT_DATA * dta = 
	(NSOBJECT_OBJECT_DATA*)malloc(sizeof(NSOBJECT_OBJECT_DATA));
    if (!dta)
        Pike_error("init_objectivec: Out of memory!\n");

    THIS->object_data = dta;

    THIS->object_data->object = NULL;
}

EXIT 
{
  if(THIS->object_data)
  {
    if(THIS->object_data->object != NULL)
      [ THIS->object_data->object release];
    free(THIS->object_data);
  }
}

}


PIKECLASS NSClass
{

typedef struct
{
    struct pike_string *classname;
    id class;
} NSCLASS_OBJECT_DATA;

CVAR NSCLASS_OBJECT_DATA   *object_data;


/*! @decl void create(string appname)
 *!   Creates a new PAM object
 *!
 *!  @param appname
 *!    sets the application name that the PAM module will identify itself as.
 *!
 */
PIKEFUN void create(string classname)
{
  id class;

  THIS->object_data->classname = make_shared_string(classname->str);

  class = objc_getClass(THIS->object_data->classname->str);
  
  if(class == nil) Pike_error("class does not exist.\n");

  THIS->object_data->class = class;

  [class retain];

  pop_n_elems(args);
}

PIKEFUN array _variables()
{
  struct objc_ivar_list * varList;
  char * varname;

  Class isa = (Class)THIS->object_data->class;
  
  if(isa == nil) Pike_error("whoa, horsie! no class for this object!\n");

   if(isa->ivars != NULL)
   {
     int i = 0;
     for(i = 0; i < isa->ivars->ivar_count; i++)
     {
        varname = isa->ivars->ivar_list[i].ivar_name;
        push_text(varname);
     }
     f_aggregate(i);
   }
   else push_int(0);  
}

PIKEFUN array _method_encoding(string selector)
{
  struct objc_method * method;
  SEL * select;
  int arguments, x;

  select = sel_registerName(selector->str);

//      method = class_getClassMethod(THIS->object_data->class, select);
      method = class_getInstanceMethod(THIS->object_data->class, select);

  if(method == NULL ) Pike_error("method does not exist.\n");

  arguments = method_getNumberOfArguments(method);

  pop_stack();

  for(x = 0; x < arguments; x++)
  {
    char * type = NULL;
    int offset;
    method_getArgumentInfo(method, x, &type, &offset);
switch(*type)
{
  case 'I':
     break;

  case ':':
     break;

  case '@':
     break;
}
    push_text(type);
  }

  f_aggregate(x);

}

PIKEFUN array _methods()
{
  void *iterator = 0;
  struct objc_method_list *methodList;
  int index;
  SEL selector;
  int x = 0;
  Class isa = (Class)THIS->object_data->class;
  
  if(isa == nil) Pike_error("whoa, horsie! no class for this object!\n");

        while (methodList = class_nextMethodList(isa, &iterator)) {
                for (index = 0; index < methodList->method_count; index++) {
                        selector = methodList->method_list[index].method_name;
      push_text((char *)selector);
      x++;
                }
        }

  f_aggregate(x);

  return;
}

PIKEFUN object new()
{
  id obj;
  struct object * nobject;

  if(THIS->object_data->class == nil) Pike_error("whoa, horsie! no class for this object!\n");

  obj = class_createInstance(THIS->object_data->class, 0);

  obj = THIS->object_data->class;

  if(obj == NULL)
    Pike_error("unable to allocate object.\n");

  nobject = NEW_NSOBJECT();
  OBJ2_NSOBJECT(nobject)->object_data->object = obj;

  [ obj retain ];

  push_object(nobject);
}

INIT
{
    NSCLASS_OBJECT_DATA * dta = 
	(NSCLASS_OBJECT_DATA*)malloc(sizeof(NSCLASS_OBJECT_DATA));
    if (!dta)
        Pike_error("init_objectivec: Out of memory!\n");

    THIS->object_data = dta;

    THIS->object_data->classname = NULL;
}

EXIT 
{
  if(THIS->object_data)
  {
    if(THIS->object_data->class != NULL)
      [ THIS->object_data->class release];
    free_string(THIS->object_data->classname);
    free(THIS->object_data);
  }
}

}

/*! @endclass
 */

/*! @endmodule
 */

/*! @endmodule
 */




#define pike_objc_type_skip_name(type) { \
	while((*type)&&(*type!='=')) \
		type++; \
	if(*type) \
		type++; \
	}

#define pike_objc_type_skip_number(type) { \
	if(*type=='+') \
		type++; \
	if(*type=='-') \
		type++; \
	while((*type)&&(*type>='0')&&(*type<='9')) \
		type++; \
	}

#define pike_objc_type_skip_past_char(type,char) { \
	while((*type)&&(*type!=char)) \
		type++; \
	if((*type)&&(*type==char)) \
		type++; \
	else\
		result=0;\
	}

unsigned pike_objc_type_alignment(char** typeptr){
	unsigned result=0;
	char* type=*typeptr;
	start:{
		char this=*type;
		type++;
		switch(this){
			case 'b':
#ifndef __NEXT_RUNTIME__
				pike_objc_type_skip_number(type);
				result=pike_objc_type_alignment(&type);
				pike_objc_type_skip_number(type);
				break;
#else
				result=__alignof__(int);
				pike_objc_type_skip_number(type);
				break;
#endif
			case 'c':
				result=__alignof__(char);
				break;
			case 'C':
				result=__alignof__(unsigned char);
				break;
			case 'd':
				result=__alignof__(double);
				break;
			case 'f':
				result=__alignof__(float);
				break;
			case 'i':
				result=__alignof__(int);
				break;
			case 'I':
				result=__alignof__(unsigned int);
				break;
			case 'l':
				result=__alignof__(long);
				break;
			case 'L':
				result=__alignof__(unsigned long);
				break;
			case 'n':
			case 'N':
			case 'o':
			case 'O':
				goto start;
			case 'q':
				result=__alignof__(long long);
				break;
			case 'Q':
				result=__alignof__(unsigned long long);
				break;
			case 'r':
				goto start;
			case 's':
				result=__alignof__(short);
				break;
			case 'S':
				result=__alignof__(unsigned short);
				break;
			case 'v':
				result=__alignof__(void);
				break;
			case 'V':
				goto start;
			case '@':
				result=__alignof__(id);
				break;
			case '#':
				result=__alignof__(Class);
				break;
			case '^':
				result=__alignof__(void*);
				pike_objc_type_alignment(&type);
				break;
			case '*':
				result=__alignof__(char*);
				break;
			case ':':
				result=__alignof__(SEL);
				break;
			case '(':{
				pike_objc_type_skip_name(type);
				if(*type){
					while((*type)&&(*type!=')')){
						unsigned alignment=pike_objc_type_alignment(&type);
						if(alignment>result)
							result=alignment;
						}
					pike_objc_type_skip_past_char(type,')');
					}
				break;
				}
			case '[':{
				pike_objc_type_skip_number(type);
				if(*type){
					unsigned alignment=pike_objc_type_alignment(&type);
					pike_objc_type_skip_past_char(type,']');
					result=alignment;
					}
				break;
				}
			case '{':{
				pike_objc_type_skip_name(type);
				if(*type){
					while((*type)&&(*type!='}')){
						unsigned alignment=pike_objc_type_alignment(&type);
						if(alignment>result)
							result=alignment;
						}
					pike_objc_type_skip_past_char(type,'}');
					}
				break;
				}
			case '?':
			default:
				result=0;
			}
		pike_objc_type_skip_number(type);
		}
	*typeptr=(result?type:nil);
	return result;
	}





unsigned pike_objc_type_size(char** typeptr){
	unsigned result=0;
	char* type=*typeptr;
	start:{
		char this=*type;
		type++;
		switch(this){
			case 'b':
#ifndef __NEXT_RUNTIME__
				pike_objc_type_skip_number(type);
				result=pike_objc_type_size(&type);
				pike_objc_type_skip_number(type);
				break;
#else
				result=sizeof(int);
				pike_objc_type_skip_number(type);
				break;
#endif
			case 'c':
				result=sizeof(char);
				break;
			case 'C':
				result=sizeof(unsigned char);
				break;
			case 'd':
				result=sizeof(double);
				break;
			case 'f':
				result=sizeof(float);
				break;
			case 'i':
				result=sizeof(int);
				break;
			case 'I':
				result=sizeof(unsigned int);
				break;
			case 'l':
				result=sizeof(long);
				break;
			case 'L':
				result=sizeof(unsigned long);
				break;
			case 'n':
			case 'N':
			case 'o':
			case 'O':
				goto start;
			case 'q':
				result=sizeof(long long);
				break;
			case 'Q':
				result=sizeof(unsigned long long);
				break;
			case 'r':
				goto start;
			case 's':
				result=sizeof(short);
				break;
			case 'S':
				result=sizeof(unsigned short);
				break;
			case 'v':
				result=sizeof(void);
				break;
			case 'V':
				goto start;
			case '@':
				result=sizeof(id);
				break;
			case '#':
				result=sizeof(Class);
				break;
			case '^':
				result=sizeof(void*);
				pike_objc_type_size(&type);
				break;
			case '*':
				result=sizeof(char*);
				break;
			case ':':
				result=sizeof(SEL);
				break;
			case '(':{
				pike_objc_type_skip_name(type);
				if(*type){
					while((*type)&&(*type!=')')){
						unsigned size=pike_objc_type_size(&type);
						if(size>result)
							result=size;
						}
					pike_objc_type_skip_past_char(type,')');
					}
				break;
				}
			case '[':{
				unsigned count=0;
				while((*type)&&((*type)>='0')&&((*type)<='9')){
					count=((*type)-'0')+(count*10);
					type++;
					}
				if(*type){
					result=count*pike_objc_type_size(&type);
					pike_objc_type_skip_past_char(type,']');
					}
				else
					result=0;
				break;
				}
			case '{':{
				unsigned max_alignment=0;
				unsigned padding;
				char* temp;
				unsigned this_alignment;
				pike_objc_type_skip_name(type);
				if(*type){
					while((*type)&&(*type!='}')){
						temp=type;
						this_alignment=pike_objc_type_alignment(&temp);

						if(this_alignment>4)
							this_alignment=4;
						if(this_alignment>max_alignment)
							max_alignment=this_alignment;

						if(result&(this_alignment-1))
							padding=this_alignment-((result&(this_alignment-1)));
						else
							padding=0;
						result=result+pike_objc_type_size(&type)+padding;
						}
					if(result&(max_alignment-1))
						padding=max_alignment-((result&(max_alignment-1)));
					else
						padding=0;
					result=result+padding;
					pike_objc_type_skip_past_char(type,'}');
					}
				break;
				}
			case '?':
			default:
				result=0;
			}
		pike_objc_type_skip_number(type);
		}
	*typeptr=(result?type:nil);
	return result;
	}
