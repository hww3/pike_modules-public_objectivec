extern id global_autorelease_pool;

PIKEFUN mixed `()(mixed ... my_arguments)
{
  struct objc_method * method;
  SEL select;
  int arguments, x;
  id wrapper;
  void * result;
  marg_list argumentList = NULL;
  int argumentOffset=0;
  char * type = NULL;
  struct NSObject_struct * d;
  id obj;
  id pool;

  pool = [global_autorelease_pool getAutoreleasePool];
  method = THIS->object_data->method;
  select = THIS->object_data->selector;


  printf("%s`()\n", (char * ) select);
  arguments = method_getNumberOfArguments(method);

  if((args) != (arguments-2))
    Pike_error("incorrect number of arguments to method provided.\n");

  marg_malloc(argumentList,method);
  if(!argumentList)
    Pike_error("Insufficient memory (Could not allocate method argument buffer).");

  // arguments 0 and 1 are the object to receive the message and the selector, respectively.
  for(x = 2; x < arguments; x++)
  {
    int offset;
    struct svalue * sv;
    sv = my_arguments+(x-2);

    method_getArgumentInfo(method, x, (const char **)(&type), &offset);
printf("argument %d %s\n", x, type);
    while((*type)&&(*type=='r' || *type =='n' || *type =='N' || *type=='o' || *type=='O' || *type =='V'))
		type++;

    switch(*type)
    {
      case 'c': 
         if(sv->type!=T_INT)
           Pike_error("Type mismatch for method argument.");
         marg_setValue(argumentList,offset,char, (char)sv->u.integer);
	 break;

      case 'C': 
         if(sv->type!=T_INT)
           Pike_error("Type mismatch for method argument.");
         marg_setValue(argumentList,offset, int, (int)sv->u.integer);
	 break;

      case 'd':
         if(sv->type!=T_FLOAT)
           Pike_error("Type mismatch for method argument.");
         marg_setValue(argumentList,offset,double , (double)sv->u.float_number);
	 break;

      case 'f':
         if(sv->type!=T_FLOAT)
           Pike_error("Type mismatch for method argument.");
         marg_setValue(argumentList,offset,float , (float)sv->u.float_number);
	 break;

      case 'i': 
         if(sv->type!=T_INT)
           Pike_error("Type mismatch for method argument.");
         marg_setValue(argumentList,offset,int, sv->u.integer);
	 break;

      case 'I': 
         if(sv->type!=T_INT)
           Pike_error("Type mismatch for method argument.");
         marg_setValue(argumentList,offset,unsigned int, sv->u.integer);
	 break;

      case 'l':
         if(sv->type!=T_INT)
           Pike_error("Type mismatch for method argument.");
         marg_setValue(argumentList,offset,long , (long)sv->u.integer);
	 break;

      case 'L':
         if(sv->type!=T_INT)
           Pike_error("Type mismatch for method argument.");
         marg_setValue(argumentList,offset,unsigned long , (unsigned long)sv->u.integer);
	 break;

      case 'q':
         if(sv->type!=T_INT)
           Pike_error("Type mismatch for method argument.");
         marg_setValue(argumentList,offset,long long , (long long)sv->u.integer);
	 break;

      case 'Q':
         if(sv->type!=T_INT)
           Pike_error("Type mismatch for method argument.");
         marg_setValue(argumentList,offset,unsigned long long , (unsigned long long)sv->u.integer);
	 break;

      case 's':
         if(sv->type!=T_INT)
           Pike_error("Type mismatch for method argument.");
         marg_setValue(argumentList,offset,short , (short)sv->u.integer);
	 break;

      case 'S':
         if(sv->type!=T_INT)
           Pike_error("Type mismatch for method argument.");
         marg_setValue(argumentList,offset,unsigned short , (unsigned short)sv->u.integer);
	 break;

      case '*': 
         if(sv->type!=T_STRING)
           Pike_error("Type mismatch for method argument..");
         marg_setValue(argumentList,offset,char *, sv->u.string->str);
	 break;
	      case ':':
	//Pike_error("unable to support type :\n");
	           marg_setValue(argumentList,offset,SEL , sel_registerName(sv->u.string->str));
	         break;

      case '@': 
         if(sv->type==T_OBJECT)
         {
           struct object * o = sv->u.object;
           if(!get_storage(o, NSObject_program))
           {
//			printf("Whee! We're wrappin' an object!\n");
			 // if we don't have a wrapped object, we should make a pike object wrapper.
			 wrapper = [PiObjCObject newWithPikeObject: o];
		//	 wrapper = [wrapper retain];
             marg_setValue(argumentList, offset, id, wrapper);
		   }
		   else
             marg_setValue(argumentList,offset,id, OBJ2_NSOBJECT(o)->object_data->object);
         }
         else if(sv->type == T_STRING)
         {
            // let's wrap the string as an NSString object.
            id str;
            NSStringEncoding enc;
            enc =  NSUTF8StringEncoding;
            push_svalue(sv);
            f_string_to_utf8(1);
            sv = &Pike_sp[-1];
            str = [[NSString alloc] initWithBytes: sv->u.string->str length: sv->u.string->len encoding: enc];
            pop_stack();
            marg_setValue(argumentList,offset,id, str);
         }
		 else
		    Pike_error("Type mismatch for method argument..");
            
	 break;

/* TODO: How should we support these? */
      case '#':
Pike_error("unable to support type #\n");
//           marg_setValue(argumentList,offset,Class , OBJ2_NSOBJECT(o)->object_data->object);
         break;


      case '^':
Pike_error("unable to support type ^\n");
//           marg_setValue(argumentList,offset,void , OBJ2_NSOBJECT(o)->object_data->object);
         break;
      case '[':
      case '{':
      case '(':
      case 'b':
      case 'v':
      default:
         Pike_error("unsupported argument type.\n");

      }
   }

  type = method->method_types;

  while((*type)&&(*type=='r' || *type =='n' || *type =='N' || *type=='o' || *type=='O' || *type =='V'))
		type++;

//  printf("TYPE: %s\n", type);
  obj = THIS->object_data->object;

  @try
  {

  switch(*type){
    case 'c':
	  THREADS_ALLOW();
      result = (INT_TYPE *) malloc(sizeof(INT_TYPE)); 
	 *(INT_TYPE *)result = (INT_TYPE)((pike_objc_unsigned_char_msgSendv)objc_msgSendv)(obj,select,method_getSizeOfArguments(method),argumentList);
	  THREADS_DISALLOW();
      push_int(*(INT_TYPE *)result);
      break;

    case 'C':
	  THREADS_ALLOW();
     result = (INT_TYPE *) malloc(sizeof(INT_TYPE)); 
	 *(INT_TYPE *)result =     (INT_TYPE)((pike_objc_unsigned_char_msgSendv)objc_msgSendv)(obj,select,method_getSizeOfArguments(method),argumentList);
	  THREADS_DISALLOW();
      push_int(*(INT_TYPE *)result);
      break;

    case 'i':
	  THREADS_ALLOW();
    result = (INT_TYPE *) malloc(sizeof(INT_TYPE)); 
	 *(INT_TYPE *)result =      (INT_TYPE)((pike_objc_int_msgSendv)objc_msgSendv)(obj,select,method_getSizeOfArguments(method),argumentList);
	  THREADS_DISALLOW();
      push_int(*(INT_TYPE *)result);
      break;
    // TODO: fix the casting... should we support auto objectize for bignums?

    case 'l':
	  THREADS_ALLOW();
    result = (INT_TYPE *) malloc(sizeof(INT_TYPE)); 
	 *(INT_TYPE *)result =     (INT_TYPE)((pike_objc_long_msgSendv)objc_msgSendv)(obj,select,method_getSizeOfArguments(method),argumentList);
	  THREADS_DISALLOW();
      push_int(*(INT_TYPE *)result);
      break;

    case 'L':
	  THREADS_ALLOW();
    result = (INT_TYPE *) malloc(sizeof(INT_TYPE)); 
	 *(INT_TYPE *)result = (INT_TYPE)((pike_objc_unsigned_long_msgSendv)objc_msgSendv)(obj,select,method_getSizeOfArguments(method),argumentList);
	  THREADS_DISALLOW();
      push_int(*(INT_TYPE *)result);
      break;

    case 'I':
	  THREADS_ALLOW();
      result = (INT_TYPE *) malloc(sizeof(INT_TYPE)); 
      *(INT_TYPE *)result = (INT_TYPE)((pike_objc_unsigned_int_msgSendv)objc_msgSendv)(obj,select,method_getSizeOfArguments(method),argumentList);
	  THREADS_DISALLOW();
      push_int(*(INT_TYPE *)result);
      break;

    case 'd':
	  THREADS_ALLOW();
    result = (FLOAT_TYPE *) malloc(sizeof(FLOAT_TYPE)); 
    *(FLOAT_TYPE *)result = (FLOAT_TYPE)((pike_objc_double_msgSendv)objc_msgSendv)(obj,select,method_getSizeOfArguments(method),argumentList);
	  THREADS_DISALLOW();
      push_float(*(FLOAT_TYPE *)result);
      break;

    case 'f':
	  THREADS_ALLOW();
      result = (FLOAT_TYPE *) malloc(sizeof(FLOAT_TYPE)); 
      *(FLOAT_TYPE *)result =  (FLOAT_TYPE)((pike_objc_float_msgSendv)objc_msgSendv)(obj,select,method_getSizeOfArguments(method),argumentList);
	  THREADS_DISALLOW();
      push_float(*(FLOAT_TYPE *)result);
      break;

    case 'q':
	  THREADS_ALLOW();
      result = (FLOAT_TYPE *) malloc(sizeof(FLOAT_TYPE)); 
      *(FLOAT_TYPE *)result = (FLOAT_TYPE)((pike_objc_long_long_msgSendv)objc_msgSendv)(obj,select,method_getSizeOfArguments(method),argumentList);
	  THREADS_DISALLOW();
      push_float(*(FLOAT_TYPE *)result);
      break;

    case 'Q':
	  THREADS_ALLOW();
      result = (FLOAT_TYPE *) malloc(sizeof(FLOAT_TYPE)); 
      *(FLOAT_TYPE *)result =     (FLOAT_TYPE)((pike_objc_unsigned_long_long_msgSendv)objc_msgSendv)(obj,select,method_getSizeOfArguments(method),argumentList);
	  THREADS_DISALLOW();
      push_float(*(FLOAT_TYPE *)result);
      break;

    case 's':
	  THREADS_ALLOW();
      result = (INT_TYPE *) malloc(sizeof(INT_TYPE)); 
      *(INT_TYPE *)result =     (INT_TYPE)((pike_objc_short_msgSendv)objc_msgSendv)(obj,select,method_getSizeOfArguments(method),argumentList);
	  THREADS_DISALLOW();
      push_int(*(INT_TYPE *)result);
      break;

    case 'S':
	  THREADS_ALLOW();
      result = (INT_TYPE *) malloc(sizeof(INT_TYPE)); 
      *(INT_TYPE *)result =     (INT_TYPE)((pike_objc_unsigned_short_msgSendv)objc_msgSendv)(obj,select,method_getSizeOfArguments(method),argumentList);
	  THREADS_DISALLOW();
      push_int(*(INT_TYPE *)result);
      break;

    case 'v':

      void_dispatch_method(obj,select,method,argumentList);

push_int(0);
      break;

    case '*':
	  THREADS_ALLOW();
      result = (char *) malloc(sizeof(char *)); 
      result = (char *)objc_msgSendv(obj,select,method_getSizeOfArguments(method),argumentList);
	  THREADS_DISALLOW();
      push_text(result);
      break;
    case '@':
      {
        struct object * o;
        id r;

	  	o = object_dispatch_method(obj,select, method,argumentList);

    	push_object(o);
		}
      break;
    case '#':
      {
        struct object * o;
        Class c;
THREADS_ALLOW();
        c = objc_msgSendv(obj,select,method_getSizeOfArguments(method),argumentList);
THREADS_DISALLOW();
        o = NEW_NSCLASS();
        OBJ2_NSCLASS(o)->object_data->class = (id)c;
        c = [(id)c retain];
        push_object(o);
      }
      break;
    case 'b':
      Pike_error("Invalid return type for method.");
    case '?':
      Pike_error("Unknown return type for method.");
    case '[':
    case '{':
    case '(':{
      char* temp=method->method_types;
      result=xmalloc(pike_objc_type_size(&temp));
	  THREADS_ALLOW();
      objc_msgSendv_stret(result,obj,select,method_getSizeOfArguments(method),argumentList);
	  THREADS_DISALLOW();
// TODO: do something with the result!
      break;
    }
  }
  [pool release];
  stack_pop_n_elems_keep_top(args);

  }
  @catch (NSException * e)
  {

    pop_n_elems(args);
    Pike_error("%s: %s\n", [(NSString *)[e name] UTF8String], [(NSString *)[e reason] UTF8String]);
  }

  if(argumentList) 
    marg_free(argumentList);

}


