/*! @module Public
 */

/*! @module ObjectiveC
 */

/*! @class MethodWrapper
 */

#define _GNU_SOURCE
#define THIS_IS_METHODWRAPPER 1
#include "piobjc.h"
#import <Foundation/NSString.h>
#import <Foundation/NSAutoreleasePool.h>
#import "PiObjCObject.h"

PIKECLASS MethodWrapper
{

  CVAR METHODWRAPPER_OBJECT_DATA   *object_data;

  int is_wrapper_initialized()
  {
    if(THIS->object_data->object == NULL || THIS->object_data->method == NULL)
      return 0;
    else return 1;
  }

  PIKEFUN string _sprintf(int type, mixed t)
  {
    char * desc;

    if(!is_wrapper_initialized())
    {
      pop_n_elems(args);
      push_text("UNINITIALIZED_WRAPPER()");
      return;
    }

    desc = malloc(strlen(THIS->object_data->object->isa->name) + strlen((char *)THIS->object_data->selector) + 2);

    if(desc == NULL)
      Pike_error("unable to allocate string.\n");

    sprintf(desc, "%s->%s", THIS->object_data->object->isa->name, (char *)THIS->object_data->selector);

    pop_n_elems(args);
    push_text(desc);
    free(desc);
    return; 
  }

PIKEFUN mixed `()(mixed ... my_arguments)
{
  struct objc_method * method;
  SEL select;
  int arguments, x;
  id wrapper;
  void * result;
  marg_list argumentList = NULL;
  int argumentOffset=0;
  char * type = NULL;

  method = THIS->object_data->method;
  select = THIS->object_data->selector;

  arguments = method_getNumberOfArguments(method);

  if((args) != (arguments-2))
    Pike_error("incorrect number of arguments to method provided.\n");

  marg_malloc(argumentList,method);
  if(!argumentList)
    Pike_error("Insufficient memory (Could not allocate method argument buffer).");

  // arguments 0 and 1 are the object to recieve the message and the selector, respectively.
  for(x = 2; x < arguments; x++)
  {
    int offset;
    struct svalue * sv;
    sv = my_arguments+(x-2);

    method_getArgumentInfo(method, x, (const char **)(&type), &offset);

    while((*type)&&(*type=='r' || *type =='n' || *type =='N' || *type=='o' || *type=='O' || *type =='V'))
		type++;

    switch(*type)
    {
      case 'c': 
         if(sv->type!=T_INT)
           Pike_error("Type mismatch for method argument.");
         marg_setValue(argumentList,offset,char, (char)sv->u.integer);
	 break;

      case 'C': 
         if(sv->type!=T_INT)
           Pike_error("Type mismatch for method argument.");
         marg_setValue(argumentList,offset, int, (int)sv->u.integer);
	 break;

      case 'd':
         if(sv->type!=T_FLOAT)
           Pike_error("Type mismatch for method argument.");
         marg_setValue(argumentList,offset,double , (double)sv->u.float_number);
	 break;

      case 'f':
         if(sv->type!=T_FLOAT)
           Pike_error("Type mismatch for method argument.");
         marg_setValue(argumentList,offset,float , (float)sv->u.float_number);
	 break;

      case 'i': 
         if(sv->type!=T_INT)
           Pike_error("Type mismatch for method argument.");
         marg_setValue(argumentList,offset,int, sv->u.integer);
	 break;

      case 'I': 
         if(sv->type!=T_INT)
           Pike_error("Type mismatch for method argument.");
         marg_setValue(argumentList,offset,unsigned int, sv->u.integer);
	 break;

      case 'l':
         if(sv->type!=T_INT)
           Pike_error("Type mismatch for method argument.");
         marg_setValue(argumentList,offset,long , (long)sv->u.integer);
	 break;

      case 'L':
         if(sv->type!=T_INT)
           Pike_error("Type mismatch for method argument.");
         marg_setValue(argumentList,offset,unsigned long , (unsigned long)sv->u.integer);
	 break;

      case 'q':
         if(sv->type!=T_INT)
           Pike_error("Type mismatch for method argument.");
         marg_setValue(argumentList,offset,long long , (long long)sv->u.integer);
	 break;

      case 'Q':
         if(sv->type!=T_INT)
           Pike_error("Type mismatch for method argument.");
         marg_setValue(argumentList,offset,unsigned long long , (unsigned long long)sv->u.integer);
	 break;

      case 's':
         if(sv->type!=T_INT)
           Pike_error("Type mismatch for method argument.");
         marg_setValue(argumentList,offset,short , (short)sv->u.integer);
	 break;

      case 'S':
         if(sv->type!=T_INT)
           Pike_error("Type mismatch for method argument.");
         marg_setValue(argumentList,offset,unsigned short , (unsigned short)sv->u.integer);
	 break;

      case '*': 
         if(sv->type!=T_STRING)
           Pike_error("Type mismatch for method argument..");
         marg_setValue(argumentList,offset,char *, sv->u.string->str);
	 break;

      case '@': 
         if(sv->type!=T_OBJECT)
           Pike_error("Type mismatch for method argument..");
         {
           struct object * o = sv->u.object;
           if(!get_storage(o, NSObject_program))
           {
			printf("Whee! We're wrappin' an object!\n");
			 // if we don't have a wrapped object, we should make a pike object wrapper.
			 wrapper = [PiObjCObject newWithPikeObject: o];
			 [wrapper retain];
             marg_setValue(argumentList, offset, id, wrapper);
		   }
		   else
             marg_setValue(argumentList,offset,id, OBJ2_NSOBJECT(o)->object_data->object);
         }
	 break;

/* TODO: How should we support these? */
      case '#':
Pike_error("unable to support type #\n");
//           marg_setValue(argumentList,offset,Class , OBJ2_NSOBJECT(o)->object_data->object);
         break;

      case ':':
Pike_error("unable to support type :\n");
//           marg_setValue(argumentList,offset,SEL , OBJ2_NSOBJECT(o)->object_data->object);
         break;

      case '^':
Pike_error("unable to support type ^\n");
//           marg_setValue(argumentList,offset,void , OBJ2_NSOBJECT(o)->object_data->object);
         break;
      case '[':
      case '{':
      case '(':
      case 'b':
      case 'v':
      default:
         Pike_error("unsupported argument type.\n");

      }
   }

  type = method->method_types;

  while((*type)&&(*type=='r' || *type =='n' || *type =='N' || *type=='o' || *type=='O' || *type =='V'))
		type++;

//  printf("TYPE: %s\n", type);

  pop_n_elems(args);

  @try
  {

  switch(*type){
    case 'c':
      push_int((INT_TYPE)((pike_objc_char_msgSendv)objc_msgSendv)(THIS->object_data->object,select,method_getSizeOfArguments(method),argumentList));
      break;
    case 'C':
      push_int((INT_TYPE)((pike_objc_unsigned_char_msgSendv)objc_msgSendv)(THIS->object_data->object,select,method_getSizeOfArguments(method),argumentList));
      break;
    case 'i':
      push_int((INT_TYPE)((pike_objc_int_msgSendv)objc_msgSendv)(THIS->object_data->object,select,method_getSizeOfArguments(method),argumentList));
      break;
    // TODO: fix the casting... should we support auto objectize for bignums?
    case 'l':
      push_int((INT_TYPE)((pike_objc_long_msgSendv)objc_msgSendv)(THIS->object_data->object,select,method_getSizeOfArguments(method),argumentList));
      break;
    case 'L':
      push_int((INT_TYPE)((pike_objc_unsigned_long_msgSendv)objc_msgSendv)(THIS->object_data->object,select,method_getSizeOfArguments(method),argumentList));
      break;
    case 'I':
      push_int((INT_TYPE)objc_msgSendv(THIS->object_data->object,select,method_getSizeOfArguments(method),argumentList));
      break;
    case 'd':
      push_float(((pike_objc_double_msgSendv)objc_msgSendv)(THIS->object_data->object,select,method_getSizeOfArguments(method),argumentList));
      break;
    case 'f':
      push_float((FLOAT_TYPE)((pike_objc_float_msgSendv)objc_msgSendv)(THIS->object_data->object,select,method_getSizeOfArguments(method),argumentList));
      break;
    case 'q':
      push_float((FLOAT_TYPE)((pike_objc_long_long_msgSendv)objc_msgSendv)(THIS->object_data->object,select,method_getSizeOfArguments(method),argumentList));
      break;
    case 'Q':
      push_float((FLOAT_TYPE)((pike_objc_unsigned_long_long_msgSendv)objc_msgSendv)(THIS->object_data->object,select,method_getSizeOfArguments(method),argumentList));
      break;
    case 's':
      push_int((INT_TYPE)((pike_objc_short_msgSendv)objc_msgSendv)(THIS->object_data->object,select,method_getSizeOfArguments(method),argumentList));
      break;
    case 'S':
      push_int((INT_TYPE)((pike_objc_unsigned_short_msgSendv)objc_msgSendv)(THIS->object_data->object,select,method_getSizeOfArguments(method),argumentList));
      break;
    case 'v':
      objc_msgSendv(THIS->object_data->object,select,method_getSizeOfArguments(method),argumentList);
      break;

    case '*':
      push_text((char *)objc_msgSendv(THIS->object_data->object,select,method_getSizeOfArguments(method),argumentList));
      break;
    case '@':
      {
        struct object * o;
        id r;
        r = objc_msgSendv(THIS->object_data->object,select,method_getSizeOfArguments(method),argumentList);
        if([r isKindOfClass: [NSString class]] == YES)
        {
          struct NSObject_struct * d;
          o = NEW_NSSTRING();
          d = (struct NSObject_struct *) get_storage(o, NSObject_program);
          if(d == NULL)
             Pike_error("Object is not an NSObject!\n");
          d->object_data->object = (id)r;
          [(id)r retain];
        }
        else
        {
          o = NEW_NSOBJECT();
          OBJ2_NSOBJECT(o)->object_data->object = (id)r;
        }
        if(! [(id)r isKindOfClass: [NSAutoreleasePool class]])
          [(id)r retain];
        push_object(o);
      }
      break;
    case '#':
      {
        struct object * o;
        Class c;
        c = objc_msgSendv(THIS->object_data->object,select,method_getSizeOfArguments(method),argumentList);
        o = NEW_NSCLASS();
        OBJ2_NSCLASS(o)->object_data->class = (id)c;
        [(id)c retain];
        push_object(o);
      }
      break;
    case 'b':
      Pike_error("Invalid return type for method.");
    case '?':
      Pike_error("Unknown return type for method.");
    case '[':
    case '{':
    case '(':{
      char* temp=method->method_types;
      result=xmalloc(pike_objc_type_size(&temp));
      objc_msgSendv_stret(result,THIS->object_data->object,select,method_getSizeOfArguments(method),argumentList);
// TODO: do something with the result!
      break;
    }
  }

  }
  @catch (NSException * e)
  {

    pop_stack();
    Pike_error("%s: %s\n", [(NSString *)[e name] UTF8String], [(NSString *)[e reason] UTF8String]);
  }

  if(argumentList) 
    marg_free(argumentList);

}


INIT
{
    METHODWRAPPER_OBJECT_DATA * dta = 
	(METHODWRAPPER_OBJECT_DATA*)malloc(sizeof(METHODWRAPPER_OBJECT_DATA));
    if (!dta)
        Pike_error("init_objectivec: Out of memory!\n");

    THIS->object_data = dta;

    THIS->object_data->object = NULL;
    THIS->object_data->selector = NULL;
    THIS->object_data->method = NULL;
}

EXIT 
{
  if(THIS->object_data)
  {
    if(THIS->object_data->object != NULL)
      [ THIS->object_data->object release];
    free(THIS->object_data);
  }
}

}


void pike_init_piobjc_methodwrapper()
{
  INIT
}

void pike_exit_piobjc_methodwrapper()
{
  EXIT
}

/*! @endclass
 */

/*! @endmodule
 */

/*! @endmodule
 */
