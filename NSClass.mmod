/* 
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 *
 * $Id: NSClass.mmod,v 1.6 2006-08-09 18:32:02 hww3 Exp $
 */

/*
 * File licensing and authorship information block.
 *
 * Version: MPL 1.1/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Initial Developer of the Original Code is
 *
 * Bill Welliver <hww3@riverweb.com>
 *
 * Portions created by the Initial Developer are Copyright (C) Bill Welliver
 * All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of the LGPL, and not to allow others to use your version
 * of this file under the terms of the MPL, indicate your decision by
 * deleting the provisions above and replace them with the notice
 * and other provisions required by the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL or the LGPL.
 *
 * Significant Contributors to this file are:
 *
 */

/*! @module Public
 */

/*! @module ObjectiveC
 */

/*! @class ObjectiveC
 */

#define _GNU_SOURCE
#define THIS_IS_NSCLASS 1

#include "piobjc.h"
#include <Foundation/NSAutoreleasePool.h>

PIKECLASS NSClass
{

CVAR NSCLASS_OBJECT_DATA   *object_data;

PIKEFUN string _sprintf(int type, mixed t)
{
  if(THIS->object_data && THIS->object_data->class &&
       THIS->object_data->class->isa)
    push_text(THIS->object_data->class->isa->name);
  else
    push_text("UNKNOWN");
}


PIKEFUN void create(string classname)
{
  id class;

  THIS->object_data->classname = make_shared_string(classname->str);

  class = objc_getClass(THIS->object_data->classname->str);
  
  if(class == nil) Pike_error("class does not exist.\n");

  THIS->object_data->class = class;

  if(! [class isKindOfClass: [NSAutoreleasePool class]])
    [class retain];

  pop_n_elems(args);
}

PIKEFUN array _variables()
{
  struct objc_ivar_list * varList;
  char * varname;

  Class isa = (Class)THIS->object_data->class;
  
  if(isa == nil) Pike_error("whoa, horsie! no class for this object!\n");

   if(isa->ivars != NULL)
   {
     int i = 0;
     for(i = 0; i < isa->ivars->ivar_count; i++)
     {
        varname = isa->ivars->ivar_list[i].ivar_name;
        push_text(varname);
     }
     f_aggregate(i);
   }
   else push_int(0);  
}

PIKEFUN array _method_encoding(string selector)
{
  struct objc_method * method;
  SEL select;
  int arguments, x;
  char * selectorName;
  int ind;

  // first, we perty up the selector.
  selectorName = malloc(selector->len + 1);
  if(selectorName == NULL)
  {
    Pike_error("unable to allocate selector storage.\n");
  }
  strncpy(selectorName, selector->str, selector->len);
  
  for(ind = 0; ind < selector->len; ind++)
  {
    if(selectorName[ind] == '_')
      selectorName[ind] = ':';
  }  
  selectorName[ind] = '\0';

  select = sel_registerName((const char *)selectorName);


//      method = class_getClassMethod(THIS->object_data->class, select);
      method = class_getInstanceMethod(THIS->object_data->class, select);

  if(method == NULL ) Pike_error("method does not exist.\n");

  arguments = method_getNumberOfArguments(method);

  pop_stack();

  for(x = 0; x < arguments; x++)
  {
    char * type = NULL;
    int offset;
    method_getArgumentInfo(method, x, (const char **)&type, &offset);
switch(*type)
{
  case 'I':
     break;

  case ':':
     break;

  case '@':
     break;
}
    push_text(type);
  }

  f_aggregate(x);

}

PIKEFUN array _methods()
{
  void *iterator = 0;
  struct objc_method_list *methodList;
  int index;
  SEL selector;
  int x = 0;
  Class isa = (Class)THIS->object_data->class;
  
  if(isa == nil) Pike_error("whoa, horsie! no class for this object!\n");

        while (methodList = class_nextMethodList(isa, &iterator)) {
                for (index = 0; index < methodList->method_count; index++) {
                        selector = methodList->method_list[index].method_name;
      push_text((char *)selector);
      x++;
                }
        }

  f_aggregate(x);

  return;
}

PIKEFUN object new()
{
  id obj;
  struct object * nobject;

  if(THIS->object_data->class == nil) Pike_error("whoa, horsie! no class for this object!\n");

  obj = THIS->object_data->class;

  if(obj == NULL)
    Pike_error("unable to allocate object.\n");

  [ obj retain ];

  if(strcmp("NSString", obj->isa->name) == 0)
  {
    struct NSObject_struct * d;

    nobject = NEW_NSSTRING();
    d = (struct NSObject_struct *) get_storage(nobject, NSObject_program);
    if(d == NULL)
      Pike_error("Object is not an NSObject!\n");
    d->object_data->object = [obj alloc];
  }
  else
  {

    nobject = NEW_NSOBJECT();
    OBJ2_NSOBJECT(nobject)->object_data->object = [obj alloc];
  }

  push_object(nobject);
}

PIKEFUN mixed `->(string selector)
{
  struct object * nmethod;
  
  struct objc_method * method;
  SEL select;
  char * selectorName = NULL;
  int ind;
  
  // first, we perty up the selector.
  selectorName = malloc(selector->len + 1);
  if(selectorName == NULL)
  {
    Pike_error("unable to allocate selector storage.\n");
  }
  strncpy(selectorName, selector->str, selector->len);

    for(ind = 0; ind < selector->len; ind++)
    {
      if(selectorName[0] != '_' && selectorName[ind] == '_')
        selectorName[ind] = ':';
    }  
    selectorName[ind] = '\0';

  printf("selectorName: %s\n", selectorName);
  pop_stack();
  push_object(Pike_fp->current_object);
  add_ref(Pike_fp->current_object);
  push_text(selectorName);
  f_index(2);
  if(Pike_sp[-1].type == PIKE_T_FUNCTION) // jackpot!
  {
    return;
  }
  select = sel_registerName(selectorName);

  method = class_getClassMethod(THIS->object_data->class->isa, select);

  if(method == nil)
  {
//     printf("no instance method named %s, trying the class.\n", selectorName);
//     method = class_getClassMethod(THIS->object_data->class->isa, select);

  }

  if(method == nil)
  {
//    printf("trying harder.\n");
    selectorName[ind] = ':';
    selectorName[ind + 1] = '\0';

    select = sel_registerName(selectorName);
    method = class_getClassMethod(THIS->object_data->class->isa, select);
  }

   //  TODO: we should check for variables.

  if(method == nil) Pike_error("method does not exist.\n");

  nmethod = NEW_METHODWRAPPER();
  OBJ2_METHODWRAPPER(nmethod)->object_data->object  = THIS->object_data->class;
  OBJ2_METHODWRAPPER(nmethod)->object_data->selector  = select;
  OBJ2_METHODWRAPPER(nmethod)->object_data->method  = method;

  push_object(nmethod);
}


INIT
{
    NSCLASS_OBJECT_DATA * dta = 
	(NSCLASS_OBJECT_DATA*)malloc(sizeof(NSCLASS_OBJECT_DATA));
    if (!dta)
        Pike_error("init_objectivec: Out of memory!\n");

    THIS->object_data = dta;

    THIS->object_data->classname = NULL;
}

EXIT 
{
  if(THIS->object_data)
  {
    if(THIS->object_data->class != NULL)
      [ THIS->object_data->class release];
    free_string(THIS->object_data->classname);
    free(THIS->object_data);
  }
}

}


void pike_init_piobjc_nsclass()
{
  INIT
}

void pike_exit_piobjc_nsclass()
{
  EXIT
}

/*! @endclass
 */

/*! @endmodule
 */

/*! @endmodule
 */

