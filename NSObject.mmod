/* 
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 *
 * $Id: NSObject.mmod,v 1.12 2006-08-30 02:28:07 hww3 Exp $
 */

/*
 * File licensing and authorship information block.
 *
 * Version: MPL 1.1/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Initial Developer of the Original Code is
 *
 * Bill Welliver <hww3@riverweb.com>
 *
 * Portions created by the Initial Developer are Copyright (C) Bill Welliver
 * All Rights Reserved.
 *
 * Contributor(s):
 *
 * Alternatively, the contents of this file may be used under the terms of
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of the LGPL, and not to allow others to use your version
 * of this file under the terms of the MPL, indicate your decision by
 * deleting the provisions above and replace them with the notice
 * and other provisions required by the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL or the LGPL.
 *
 * Significant Contributors to this file are:
 *
 */

/*! @module Public
 */

/*! @module ObjectiveC
 */

/*! @class ObjectiveC
 */

#define _GNU_SOURCE
#define THIS_IS_NSOBJECT 1
#include "piobjc.h"
#include <Foundation/NSAutoreleasePool.h>

PIKECLASS NSObject
{

CVAR NSOBJECT_OBJECT_DATA   *object_data;

PIKEFUN string _sprintf(int type, mixed t)
{
  char * desc;

  desc = malloc(strlen(THIS->object_data->object->isa->name) + strlen("()"));

  if(desc == NULL)
    Pike_error("unable to allocate string.\n");

  sprintf(desc, "%s()", THIS->object_data->object->isa->name);
  push_text(desc);
  free(desc);
}

PIKEFUN mixed `->(string selector)
{
  struct object * nmethod;
  
  struct objc_method * method;
  SEL select;
  char * selectorName = NULL;
  int ind;

  if(selector->len == 0) 
  {
    pop_stack();
    push_int(0);
    return;
  }  

  // first, we perty up the selector.
  selectorName = malloc(selector->len + 1);
  if(selectorName == NULL)
  {
    Pike_error("unable to allocate selector storage.\n");
  }
  strncpy(selectorName, selector->str, selector->len);
  
  for(ind = 0; ind < selector->len; ind++)
  {
    if(selectorName[ind] == '_')
      selectorName[ind] = ':';
  }  
  selectorName[ind] = '\0';

  pop_stack();
  push_object(Pike_fp->current_object);
  add_ref(Pike_fp->current_object);
  push_text(selectorName);
  f_index(2);
  if(Pike_sp[-1].type == PIKE_T_FUNCTION) // jackpot!
  {
    return;
  }
  else
  {
    pop_stack();
  }
  select = sel_registerName(selectorName);

  method = class_getInstanceMethod(THIS->object_data->object->isa, select);

  if(method == nil)
  {
//     printf("no instance method named %s, trying the class.\n", selectorName);
//     method = class_getClassMethod(THIS->object_data->object->isa, select);

  }

  if(method == nil)
  {
//    printf("trying harder.\n");
    selectorName[ind] = ':';
    selectorName[ind + 1] = '\0';

    select = sel_registerName(selectorName);
    method = class_getInstanceMethod(THIS->object_data->object->isa, select);
  }

   //  TODO: we should check for variables.

  if(method == nil)
  {
    push_int(0);
    return;
  // Pike_error("method does not exist.\n");
  } 

  nmethod = NEW_METHODWRAPPER();
  OBJ2_METHODWRAPPER(nmethod)->object_data->object  = THIS->object_data->object;
  OBJ2_METHODWRAPPER(nmethod)->object_data->selector  = select;
  OBJ2_METHODWRAPPER(nmethod)->object_data->method  = method;

  if(! [THIS->object_data->object isKindOfClass: [NSAutoreleasePool class]])
    [THIS->object_data->object retain];

  push_object(nmethod);
}

PIKEFUN array _indices()
{
  void *iterator = 0;
  struct objc_method_list *methodList;
  int index;
  SEL selector;
  int x = 0;
  int y = 0;
  Class isa = (Class)THIS->object_data->object->isa;
  
  if(isa == nil) Pike_error("whoa, horsie! no class for this object!\n");

        while (methodList = class_nextMethodList(isa, &iterator)) 
        {
            for (index = 0; index < methodList->method_count; index++) 
            {
              selector = methodList->method_list[index].method_name;                        
              push_text((char *)selector);
              x++;
            }
        }

  f_aggregate(x);

  return;
}

INIT
{
    NSOBJECT_OBJECT_DATA * dta = 
	(NSOBJECT_OBJECT_DATA*)malloc(sizeof(NSOBJECT_OBJECT_DATA));

    if (!dta)
        Pike_error("init_objectivec: Out of memory!\n");

    THIS->object_data = dta;
    THIS->object_data->object = NULL;
}

EXIT 
{
  if(THIS->object_data)
  {
    if(THIS->object_data->object != NULL)
      [ THIS->object_data->object release];
    free(THIS->object_data);
  }
}

}

void pike_init_piobjc_nsobject()
{
  INIT
}

void pike_exit_piobjc_nsobject()
{
  EXIT
}

/*! @endclass
 */

/*! @endmodule
 */

/*! @endmodule
 */

